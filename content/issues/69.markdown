<!-- 2017-08-24 -->

Welcome to another issue of Haskell Weekly!
Haskell is a purely functional programming language that focuses on correctness, productivity, and expressiveness.
This is a weekly summary of what's going on in its community.

Want to see something featured in Haskell Weekly?
We love contributions!
Tweet us at [@HaskellWeekly](https://twitter.com/haskellweekly) or [open a pull request](https://github.com/haskellweekly/haskellweekly.github.io).

## Featured

-   [Abusing Haskell dependent types to make Redis queues safer](https://medium.com/@zyxoas/abusing-haskell-dependent-types-to-make-redis-queues-safer-cc31db943b6c)

    > I don't know about you, but quite frankly I'm tired of seeing the same tired vector example being used to demonstrate why dependent types are useful.

-   [Backpack for deep learning](http://blog.ezyang.com/2017/08/backpack-for-deep-learning/)

    > Although there many different types of tensor,  the computations for each type of tensor are the same, i.e, they share the same interface. Since Backpack lets you program against one interface which can have multiple implementations, it is the perfect tool for implementing a tensor library.

-   [Diversity through inline code](https://www.tweag.io/posts/2017-08-17-inline-code.html)

    > Haskell is an awesome language, but we need to remember that it is not very useful in isolation. In almost any realistic application, Haskell has to coexist with other languages, even if only to call existing C libraries or to make use of operating system services.

-   [Writing a ZX Spectrum game in Haskell](https://dpwright.com/posts/2015/07/17/writing-a-zx-spectrum-game-in-haskell/)

    > Haskell, the world's finest imperative programming language, can now be used to write games for the ZX Spectrum, the world's finest 80s microcomputer.

-   [Functors, applicatives, and monads: You don't need to know theory to use them](https://joyfulmantis.github.io/posts/2017-08-23-functors-applicatives-monads.html)

    > Figuring out how to use the common functional programming type classess is not as hard as you would think. The key here is not to start with understanding the category theory behind them, but rather first start with using their implementations in the standard datatypes.

-   [`fmap` in applicative and monad](http://www.halogenandtoast.com/fmap-in-applicative-and-monad/)

    > `fmap` can be implemented using the `Applicative` methods, so every `Applicative` is a functor whether we like it or not; the `Functor` constraint forces us to be honest.

-   [Coyoneda and `fmap` fusion](http://alpmestan.com/posts/2017-08-17-coyoneda-fmap-fusion.html)

    > Let's quickly see how the (dual variant of the) Yoneda lemma can speed up some Haskell programs --- more specifically ones that are repeatedly calling `fmap` to transform some data within a `Functor`.

## Jobs

todo

## In brief

todo

## Package of the week

This week's package of the week is [reflex-sdl2](https://hackage.haskell.org/package/reflex-sdl2-0.1.0.0),
a minimal host for SDL2-based Reflex apps.

## Call for participation

-   [haskell-src-exts: Support DerivingStrategies](https://github.com/haskell-suite/haskell-src-exts/issues/375)
-   [Idris-dev: Idris exits when parsing malformed code file](https://github.com/idris-lang/Idris-dev/issues/4013)
-   [stack: Listing flags in stack.yaml gives "Invalid flag specification"](https://github.com/commercialhaskell/stack/issues/3374)

## Events

todo
